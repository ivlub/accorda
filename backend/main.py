from fastapi import FastAPI, HTTPException, File, UploadFile
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import uvicorn
import os
import shutil
import logging
from pathlib import Path

# Import services
from ai_service import generate_text_from_gemini
from text_extractor import extract_text # Import the new extractor

# Configure logging (ensure it's configured)
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()

# Define upload directory within the container
UPLOAD_DIR = Path("/app/uploads")
UPLOAD_DIR.mkdir(parents=True, exist_ok=True) # Create directory if it doesn't exist

# Allow CORS for frontend development
origins = [
    "http://localhost",
    "http://localhost:5173", # Default Svelte/Vite dev port
    "http://127.0.0.1:5173",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/api/hello")
async def read_root():
    return {"message": "Hello from FastAPI!"}

# --- New AI Endpoint --- 

class AIPrompt(BaseModel):
    prompt: str
    model: str | None = None # Optional: specify a model like 'gemini-pro'

@app.post("/api/generate")
async def generate_ai_text(request: AIPrompt):
    """Receives a prompt and returns text generated by the AI service."""
    if not request.prompt:
        raise HTTPException(status_code=400, detail="Prompt cannot be empty")
    
    # Use the provided model or the default from ai_service
    model_to_use = request.model if request.model else None 
    
    try:
        if model_to_use:
            generated_text = await generate_text_from_gemini(request.prompt, model_name=model_to_use)
        else:
            generated_text = await generate_text_from_gemini(request.prompt)
        
        if generated_text.startswith("Error:"):
            # Handle errors reported by the service itself
            raise HTTPException(status_code=500, detail=generated_text)
            
        return {"prompt": request.prompt, "response": generated_text}
    except Exception as e:
        # Catch potential unexpected errors during the call
        # Log the error e
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred: {e}")

# --- File Extraction Endpoint --- 

@app.post("/api/extract_text")
async def handle_text_extraction(file: UploadFile = File(...) ):
    """Receives a file (PDF or DOCX), extracts text, and returns it."""
    
    # Basic validation for filename and extension
    filename = file.filename
    if not filename:
        raise HTTPException(status_code=400, detail="No filename provided.")
        
    file_extension = Path(filename).suffix.lower()
    if file_extension not in [".pdf", ".docx"]:
        raise HTTPException(status_code=415, detail=f"Unsupported file type: '{file_extension}'. Please upload a .pdf or .docx file.")

    # Define temporary file path
    temp_file_path = UPLOAD_DIR / filename 
    # Warning: This simple naming can cause conflicts if multiple users upload files
    # with the same name concurrently. A better approach would use unique IDs (e.g., uuid).
    
    logger.info(f"Receiving file: {filename}. Saving temporarily to {temp_file_path}")

    try:
        # Save the uploaded file temporarily
        with temp_file_path.open("wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
            logger.info(f"Successfully saved temporary file: {temp_file_path}")

        # Extract text using the utility function
        extracted_content = extract_text(str(temp_file_path))

        if extracted_content is None:
            # extract_text logs errors, but we should inform the client
            logger.warning(f"Text extraction returned None for file: {filename}")
            # Check if file still exists before raising; maybe it was invalid
            if temp_file_path.exists():
                 raise HTTPException(status_code=500, detail="Failed to extract text from the file. It might be corrupted or empty.")
            else:
                 # This case shouldn't happen if saving succeeded, but good to check
                 raise HTTPException(status_code=500, detail="Internal error during file processing.")

        logger.info(f"Successfully extracted text from {filename}")
        return {"filename": filename, "text": extracted_content}

    except HTTPException as http_exc: 
        # Re-raise HTTPExceptions directly (like the 415 Unsupported Media Type)
        raise http_exc
    except Exception as e:
        logger.error(f"Error processing file {filename}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred while processing the file: {e}")
    finally:
        # Ensure the temporary file is deleted
        if temp_file_path.exists():
            try:
                temp_file_path.unlink()
                logger.info(f"Successfully deleted temporary file: {temp_file_path}")
            except Exception as del_e:
                logger.error(f"Failed to delete temporary file {temp_file_path}: {del_e}")
        # Close the uploaded file handle
        await file.close()

# Note: Uvicorn reload is handled by the 'watchfiles' command in the Dockerfile CMD 