from fastapi import FastAPI, HTTPException, File, UploadFile
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import uvicorn
import os
import shutil
import logging
from pathlib import Path
from typing import List, Literal
from jinja2 import Environment, FileSystemLoader, select_autoescape
import json

# Import services
from ai_service import generate_text_from_gemini
from text_extractor import extract_text

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()

# Define upload directory within the container
UPLOAD_DIR = Path("/app/uploads")
UPLOAD_DIR.mkdir(parents=True, exist_ok=True)

# Define template directory
TEMPLATE_DIR = Path("/app/templates") # Assuming templates are at /app/templates in container
PROMPT_DIR = Path("/app/prompts") # Define prompt directory

# Setup Jinja2 environment
if TEMPLATE_DIR.is_dir():
    jinja_env = Environment(
        loader=FileSystemLoader(str(TEMPLATE_DIR)),
        autoescape=select_autoescape(['html', 'xml', 'jinja'])
    )
    logger.info(f"Jinja2 environment loaded from {TEMPLATE_DIR}")
else:
    jinja_env = None
    logger.error(f"Jinja2 template directory not found: {TEMPLATE_DIR}. Categorization endpoint may fail.")

# Define contract categories
# TODO: Consider moving this to a config file or database
CONTRACT_CATEGORIES = [
    "Sale and purchase",
    "Service provision",
    "Mandate",
    "Deposit",
    "Contract work",
    "Transport",
    "For use of a tangible good",
    "Money for money: Loan",
    "For use of an intangible good",
    "License agreement",
    "For access",
    "Donation",
    "Commodatum",
    "Association contract",
    "Cooperative contract",
    "Company contract",
    "Distribution/Franchise contract",
    "Guarantee contracts",
    "Gambling contract",
    "Contract in favor of a third party",
    "Contract by person to be named",
    "Contract of assignment of contractual position: Promise to contract",
    "Non-Disclosure Agreement",
    "Intellectual Property Agreement",
]

# Allow CORS for frontend development
origins = [
    "http://localhost",
    "http://localhost:5173",
    "http://127.0.0.1:5173",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- Health check / Hello World Endpoint --- 
@app.get("/api/hello")
async def read_root():
    return {"message": "Hello from FastAPI!"}

# --- New AI Endpoint --- 

class AIPrompt(BaseModel):
    prompt: str
    model: str | None = None # Optional: specify a model like 'gemini-pro'

@app.post("/api/generate")
async def generate_ai_text(request: AIPrompt):
    """Receives a prompt and returns text generated by the AI service."""
    if not request.prompt:
        raise HTTPException(status_code=400, detail="Prompt cannot be empty")
    
    # Use the provided model or the default from ai_service
    model_to_use = request.model if request.model else None 
    
    try:
        if model_to_use:
            generated_text = await generate_text_from_gemini(request.prompt, model_name=model_to_use)
        else:
            generated_text = await generate_text_from_gemini(request.prompt)
        
        if generated_text.startswith("Error:"):
            # Handle errors reported by the service itself
            raise HTTPException(status_code=500, detail=generated_text)
            
        return {"prompt": request.prompt, "response": generated_text}
    except Exception as e:
        # Catch potential unexpected errors during the call
        # Log the error e
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred: {e}")

# --- File Extraction Endpoint --- 

@app.post("/api/extract_text")
async def handle_text_extraction(file: UploadFile = File(...) ):
    """Receives a file (PDF or DOCX), extracts text, and returns it."""
    
    # Basic validation for filename and extension
    filename = file.filename
    if not filename:
        raise HTTPException(status_code=400, detail="No filename provided.")
        
    file_extension = Path(filename).suffix.lower()
    if file_extension not in [".pdf", ".docx"]:
        raise HTTPException(status_code=415, detail=f"Unsupported file type: '{file_extension}'. Please upload a .pdf or .docx file.")

    # Define temporary file path
    temp_file_path = UPLOAD_DIR / filename 
    # Warning: This simple naming can cause conflicts if multiple users upload files
    # with the same name concurrently. A better approach would use unique IDs (e.g., uuid).
    
    logger.info(f"Receiving file: {filename}. Saving temporarily to {temp_file_path}")

    try:
        # Save the uploaded file temporarily
        with temp_file_path.open("wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
            logger.info(f"Successfully saved temporary file: {temp_file_path}")

        # Extract text using the utility function
        extracted_content = extract_text(str(temp_file_path))

        if extracted_content is None:
            # extract_text logs errors, but we should inform the client
            logger.warning(f"Text extraction returned None for file: {filename}")
            # Check if file still exists before raising; maybe it was invalid
            if temp_file_path.exists():
                 raise HTTPException(status_code=500, detail="Failed to extract text from the file. It might be corrupted or empty.")
            else:
                 # This case shouldn't happen if saving succeeded, but good to check
                 raise HTTPException(status_code=500, detail="Internal error during file processing.")

        logger.info(f"Successfully extracted text from {filename}")
        return {"filename": filename, "text": extracted_content}

    except HTTPException as http_exc: 
        # Re-raise HTTPExceptions directly (like the 415 Unsupported Media Type)
        raise http_exc
    except Exception as e:
        logger.error(f"Error processing file {filename}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred while processing the file: {e}")
    finally:
        # Ensure the temporary file is deleted
        if temp_file_path.exists():
            try:
                temp_file_path.unlink()
                logger.info(f"Successfully deleted temporary file: {temp_file_path}")
            except Exception as del_e:
                logger.error(f"Failed to delete temporary file {temp_file_path}: {del_e}")
        # Close the uploaded file handle
        await file.close()


@app.post("/api/analyze/categorize")
async def categorize_contract(file: UploadFile = File(...)):
    """Receives a contract file, extracts text, asks AI to categorize it, and returns the category."""
    
    if not jinja_env:
         raise HTTPException(status_code=500, detail="Template engine not initialized. Check server logs.")

    filename = file.filename
    if not filename:
        raise HTTPException(status_code=400, detail="No filename provided.")
        
    # Check supported file types (matching text_extractor capabilities)
    file_extension = Path(filename).suffix.lower()
    if file_extension not in [".pdf", ".docx"]:
        raise HTTPException(status_code=415, detail=f"Unsupported file type: '{file_extension}'. Only .pdf and .docx supported for categorization.")

    temp_file_path = UPLOAD_DIR / f"categorize_{filename}" # Use prefix to avoid potential clashes
    logger.info(f"[Categorize] Receiving file: {filename}. Saving temporarily to {temp_file_path}")

    extracted_content = None
    try:
        # 1. Save file temporarily
        with temp_file_path.open("wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
            logger.info(f"[Categorize] Successfully saved temporary file: {temp_file_path}")

        # 2. Extract text
        extracted_content = extract_text(str(temp_file_path))
        if not extracted_content:
            logger.error(f"[Categorize] Text extraction failed or yielded empty content for: {filename}")
            raise HTTPException(status_code=500, detail="Failed to extract text from the file. It might be corrupted, empty, or password-protected.")
        logger.info(f"[Categorize] Successfully extracted text from {filename}. Length: {len(extracted_content)}")
        
        # Truncate very long text to avoid exceeding AI model limits 
        MAX_TEXT_LENGTH = 50000 # Example limit, adjust based on model and needs. TODO: evaluete what this sould be 
        if len(extracted_content) > MAX_TEXT_LENGTH:
             logger.warning(f"[Categorize] Truncating text for {filename} from {len(extracted_content)} to {MAX_TEXT_LENGTH} characters.")
             extracted_content = extracted_content[:MAX_TEXT_LENGTH] + "... [TRUNCATED]"

        # 3. Prepare the prompt using Jinja template
        try:
            template = jinja_env.get_template("category_prompt.jinja")
            prompt = template.render(document_text=extracted_content, categories=CONTRACT_CATEGORIES)
            logger.info(f"[Categorize] Generated prompt for {filename}")
        except Exception as template_e:
            logger.error(f"[Categorize] Failed to render Jinja template: {template_e}", exc_info=True)
            raise HTTPException(status_code=500, detail="Internal server error: Failed to prepare analysis prompt.")

        # 4. Call the AI service
        logger.info(f"[Categorize] Sending request to AI for {filename}")
        ai_response_raw = await generate_text_from_gemini(prompt)
        
        if ai_response_raw.startswith("Error:"):
            logger.error(f"[Categorize] AI service returned an error for {filename}: {ai_response_raw}")
            raise HTTPException(status_code=502, detail=f"AI service failed: {ai_response_raw}")
        
        # 5. Process AI response (basic validation)
        suggested_category = ai_response_raw.strip()
        logger.info(f"[Categorize] Received category suggestion '{suggested_category}' for {filename}")

        # Optional: Validate if the category is in our list (AI might hallucinate)
        if suggested_category not in CONTRACT_CATEGORIES:
            logger.warning(f"[Categorize] AI suggested category '{suggested_category}' which is not in the predefined list for {filename}. Using 'Other'.")
            final_category = "Other"
        else:
            final_category = suggested_category

        logger.info(f"[Categorize] Final category for {filename}: {final_category}")
        return {"filename": filename, "category": final_category}

    except HTTPException as http_exc:
        # Re-raise known HTTP exceptions
        raise http_exc
    except Exception as e:
        logger.error(f"[Categorize] Error processing file {filename}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred during categorization: {e}")
    finally:
        # 6. Clean up temporary file
        if temp_file_path and temp_file_path.exists():
            try:
                temp_file_path.unlink()
                logger.info(f"[Categorize] Successfully deleted temporary file: {temp_file_path}")
            except Exception as del_e:
                logger.error(f"[Categorize] Failed to delete temporary file {temp_file_path}: {del_e}")
        # Close the uploaded file handle
        if file:
            await file.close()

# --- New Summary Endpoint --- 

@app.post("/api/analyze/summary")
async def summarize_contract(file: UploadFile = File(...)):
    """Receives a contract file, extracts text, asks AI to summarize it, and returns the summary."""
    
    if not jinja_env:
         raise HTTPException(status_code=500, detail="Template engine not initialized. Check server logs.")

    filename = file.filename
    if not filename:
        raise HTTPException(status_code=400, detail="No filename provided.")
        
    # Check supported file types
    file_extension = Path(filename).suffix.lower()
    if file_extension not in [".pdf", ".docx"]:
        raise HTTPException(status_code=415, detail=f"Unsupported file type: '{file_extension}'. Only .pdf and .docx supported for summarization.")

    temp_file_path = UPLOAD_DIR / f"summary_{filename}" # Use prefix to avoid potential clashes
    logger.info(f"[Summary] Receiving file: {filename}. Saving temporarily to {temp_file_path}")

    extracted_content = None
    try:
        # 1. Save file temporarily
        with temp_file_path.open("wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
            logger.info(f"[Summary] Successfully saved temporary file: {temp_file_path}")

        # 2. Extract text
        extracted_content = extract_text(str(temp_file_path))
        if not extracted_content:
            logger.error(f"[Summary] Text extraction failed or yielded empty content for: {filename}")
            raise HTTPException(status_code=500, detail="Failed to extract text from the file. It might be corrupted, empty, or password-protected.")
        logger.info(f"[Summary] Successfully extracted text from {filename}. Length: {len(extracted_content)}")
        
        # Truncate very long text (consider a larger limit for summaries?)
        MAX_TEXT_LENGTH = 100000 # Example limit, adjust based on model and needs. TODO: evaluate what this should be 
        if len(extracted_content) > MAX_TEXT_LENGTH:
             logger.warning(f"[Summary] Truncating text for {filename} from {len(extracted_content)} to {MAX_TEXT_LENGTH} characters.")
             extracted_content = extracted_content[:MAX_TEXT_LENGTH] + "... [TRUNCATED]"

        # 3. Prepare the prompt using Jinja template
        try:
            template = jinja_env.get_template("summary_prompt.jinja")
            prompt = template.render(document_text=extracted_content)
            logger.info(f"[Summary] Generated prompt for {filename}")
        except Exception as template_e:
            logger.error(f"[Summary] Failed to render Jinja template: {template_e}", exc_info=True)
            raise HTTPException(status_code=500, detail="Internal server error: Failed to prepare analysis prompt.")

        # 4. Call the AI service
        logger.info(f"[Summary] Sending request to AI for {filename}")
        ai_response_raw = await generate_text_from_gemini(prompt) # Consider using a specific model if needed
        
        if ai_response_raw.startswith("Error:"):
            logger.error(f"[Summary] AI service returned an error for {filename}: {ai_response_raw}")
            raise HTTPException(status_code=502, detail=f"AI service failed: {ai_response_raw}")
        
        # 5. Process AI response (basic cleanup)
        summary_text = ai_response_raw.strip()
        logger.info(f"[Summary] Received summary for {filename}. Length: {len(summary_text)}")

        return {"filename": filename, "summary": summary_text}

    except HTTPException as http_exc:
        # Re-raise known HTTP exceptions
        raise http_exc
    except Exception as e:
        logger.error(f"[Summary] Error processing file {filename}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred during summarization: {e}")
    finally:
        # 6. Clean up temporary file
        if temp_file_path and temp_file_path.exists():
            try:
                temp_file_path.unlink()
                logger.info(f"[Summary] Successfully deleted temporary file: {temp_file_path}")
            except Exception as del_e:
                logger.error(f"[Summary] Failed to delete temporary file {temp_file_path}: {del_e}")
        # Close the uploaded file handle
        if file:
            await file.close()

# --- Helper function to load JSON ---
def load_json_file(file_path: Path):
    if not file_path.is_file():
        logger.error(f"JSON file not found: {file_path}")
        return None
    try:
        with file_path.open("r") as f:
            return json.load(f)
    except Exception as e:
        logger.error(f"Error loading JSON file {file_path}: {e}", exc_info=True)
        return None

# --- Pydantic Models for Contract Requirements Check ---

class RequirementCheckResult(BaseModel):
    met: bool | Literal['maybe']
    explanation: str

class CompletenessCheck(BaseModel):
    date_of_contract_formation: RequirementCheckResult
    parties_involved: RequirementCheckResult
    object_of_contract: RequirementCheckResult
    obligations_of_parties: RequirementCheckResult
    date_of_conclusion: RequirementCheckResult | None = None # Optional based on description

class PrecisionCheck(BaseModel):
    terms_clearly_defined: RequirementCheckResult

class FirmnessCheck(BaseModel):
    reciprocal_obligations_established: RequirementCheckResult

class FormalAdequacyCheck(BaseModel):
    formal_requirements_met: RequirementCheckResult

class ContractRequirementsResponse(BaseModel):
    Completeness: CompletenessCheck
    Precision: PrecisionCheck
    Firmness: FirmnessCheck
    FormalAdequacy: FormalAdequacyCheck


# --- Contract Requirements Check Endpoint ---

# Load schema and example at startup (or handle potential errors)
REQUIREMENTS_SCHEMA_DATA = load_json_file(PROMPT_DIR / "requirements_schema.json")
REQUIREMENTS_OUTPUT_EXAMPLE_DATA = load_json_file(PROMPT_DIR / "requirements_output_example.json")

@app.post("/api/analyze/check-requirements", response_model=ContractRequirementsResponse)
async def check_contract_requirements(file: UploadFile = File(...)):
    """
    Receives a contract file, extracts text, asks AI to check requirements 
    based on a predefined schema, and returns the structured result.
    """
    if not jinja_env:
         raise HTTPException(status_code=500, detail="Template engine not initialized. Check server logs.")
    if REQUIREMENTS_SCHEMA_DATA is None or REQUIREMENTS_OUTPUT_EXAMPLE_DATA is None:
         raise HTTPException(status_code=500, detail="Failed to load requirement definition files. Check server logs.")

    filename = file.filename
    if not filename:
        raise HTTPException(status_code=400, detail="No filename provided.")
        
    file_extension = Path(filename).suffix.lower()
    if file_extension not in [".pdf", ".docx"]:
        raise HTTPException(status_code=415, detail=f"Unsupported file type: '{file_extension}'. Only .pdf and .docx supported.")

    temp_file_path = UPLOAD_DIR / f"requirements_{filename}"
    logger.info(f"[Requirements] Receiving file: {filename}. Saving temporarily to {temp_file_path}")

    extracted_content = None
    try:
        # 1. Save file temporarily
        with temp_file_path.open("wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
            logger.info(f"[Requirements] Successfully saved temporary file: {temp_file_path}")

        # 2. Extract text
        extracted_content = extract_text(str(temp_file_path))
        if not extracted_content:
            logger.error(f"[Requirements] Text extraction failed or yielded empty content for: {filename}")
            raise HTTPException(status_code=500, detail="Failed to extract text from the file.")
        logger.info(f"[Requirements] Successfully extracted text from {filename}. Length: {len(extracted_content)}")
        
        # Truncate long text if necessary
        MAX_TEXT_LENGTH = 50000 # Use the same limit as categorization for consistency
        if len(extracted_content) > MAX_TEXT_LENGTH:
             logger.warning(f"[Requirements] Truncating text for {filename} from {len(extracted_content)} to {MAX_TEXT_LENGTH} characters.")
             extracted_content = extracted_content[:MAX_TEXT_LENGTH] + "... [TRUNCATED]"

        # 3. Prepare the prompt using Jinja template
        try:
            schema_str = json.dumps(REQUIREMENTS_SCHEMA_DATA, indent=2)
            output_format_str = json.dumps(REQUIREMENTS_OUTPUT_EXAMPLE_DATA, indent=2)
            
            template = jinja_env.get_template("requirements_prompt.jinja")
            prompt = template.render(
                document_text=extracted_content, 
                requirements_schema_str=schema_str,
                output_format_example_str=output_format_str
            )
            logger.info(f"[Requirements] Generated prompt for {filename}")
        except Exception as template_e:
            logger.error(f"[Requirements] Failed to render Jinja template: {template_e}", exc_info=True)
            raise HTTPException(status_code=500, detail="Internal server error: Failed to prepare analysis prompt.")


        # 4. Call the AI service
        logger.info(f"[Requirements] Sending request to AI for {filename}")
        ai_response_raw = await generate_text_from_gemini(prompt) 
        
        if ai_response_raw.startswith("Error:"):
            logger.error(f"[Requirements] AI service returned an error for {filename}: {ai_response_raw}")
            raise HTTPException(status_code=502, detail=f"AI service failed: {ai_response_raw}")

        # 5. Process and validate AI response
        logger.info(f"[Requirements] Received raw response from AI for {filename}. Length: {len(ai_response_raw)}")
        
        # Attempt to clean the response (remove potential markdown/code blocks)
        ai_response_json_str = ai_response_raw.strip()
        if ai_response_json_str.startswith("```json"):
            ai_response_json_str = ai_response_json_str[7:] # Remove ```json
        if ai_response_json_str.startswith("```"): # Handle potential ``` start without language
             ai_response_json_str = ai_response_json_str[3:]
        if ai_response_json_str.endswith("```"):
            ai_response_json_str = ai_response_json_str[:-3] # Remove ```
        ai_response_json_str = ai_response_json_str.strip() # Strip again after potential removals
        
        # --- FIX: Replace unquoted 'maybe' --- 
        # Sometimes the AI might forget quotes around the string "maybe"
        ai_response_json_str = ai_response_json_str.replace(': maybe', ': "maybe"') 
        # Consider adding variations if needed, e.g., .replace(':maybe', ': "maybe"')
        # --------------------------------------

        try:
            ai_response_data = json.loads(ai_response_json_str)
            # Validate the structure using the Pydantic model
            validated_response = ContractRequirementsResponse(**ai_response_data)
            logger.info(f"[Requirements] Successfully parsed and validated AI response for {filename}")

            # --- Override Formal Adequacy --- 
            logger.info(f"[Requirements] Overriding FormalAdequacy result for {filename}")
            validated_response.FormalAdequacy.formal_requirements_met.met = "maybe"
            validated_response.FormalAdequacy.formal_requirements_met.explanation = "For formal adequacy, verify the applicable legal requirements in the relevant jurisdiction for the specific type of contract."
            # --------------------------------

            return validated_response
        except json.JSONDecodeError:
            logger.error(f"[Requirements] Failed to decode AI response JSON for {filename}. Cleaned Response: {ai_response_json_str}", exc_info=True) # Log the cleaned string
            raise HTTPException(status_code=502, detail="AI service returned invalid JSON.")
        except Exception as e: # Catch Pydantic validation errors or other issues
             logger.error(f"[Requirements] Failed to validate AI response structure for {filename}. Error: {e}. Cleaned Response: {ai_response_json_str}", exc_info=True) # Log the cleaned string
             raise HTTPException(status_code=502, detail=f"AI service response failed validation: {e}")

    except HTTPException as http_exc:
        # Re-raise HTTPExceptions (e.g., from file handling)
        raise http_exc
    except Exception as e:
        logger.error(f"[Requirements] Error processing file {filename}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred: {e}")
    finally:
        # Ensure the temporary file is deleted
        if temp_file_path.exists():
            try:
                temp_file_path.unlink()
                logger.info(f"[Requirements] Successfully deleted temporary file: {temp_file_path}")
            except Exception as del_e:
                logger.error(f"[Requirements] Failed to delete temporary file {temp_file_path}: {del_e}")
        # Close the uploaded file handle
        await file.close()

# --- Main execution ---
if __name__ == "__main__":
    # Determine host based on environment (e.g., Docker container vs local)
    # Docker typically uses 0.0.0.0 to be accessible outside the container
    host = os.getenv("HOST", "127.0.0.1") 
    port = int(os.getenv("PORT", 8000))
    
    # Log the UPLOAD_DIR and TEMPLATE_DIR at startup
    logger.info(f"FastAPI application starting up...")
    logger.info(f"Upload directory set to: {UPLOAD_DIR.resolve()}")
    if jinja_env:
        logger.info(f"Template directory set to: {TEMPLATE_DIR.resolve()}")
    else:
        logger.warning(f"Template directory not found or not configured.")
        
    uvicorn.run(app, host=host, port=port) # Corrected: pass app object 