from fastapi import FastAPI, HTTPException, File, UploadFile
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import uvicorn
import os
import shutil
import logging
from pathlib import Path
from typing import List, Literal, Dict
from jinja2 import Environment, FileSystemLoader, select_autoescape
import json

# Import services
from ai_service import generate_text_from_gemini
from text_extractor import extract_text

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()

# Define upload directory within the container
UPLOAD_DIR = Path("/app/uploads")
UPLOAD_DIR.mkdir(parents=True, exist_ok=True)

# Define template directory
TEMPLATE_DIR = Path("/app/templates") # Assuming templates are at /app/templates in container
PROMPT_DIR = Path("/app/prompts") # Define prompt directory

# Setup Jinja2 environment
if TEMPLATE_DIR.is_dir():
    jinja_env = Environment(
        loader=FileSystemLoader(str(TEMPLATE_DIR)),
        autoescape=select_autoescape(['html', 'xml', 'jinja'])
    )
    logger.info(f"Jinja2 environment loaded from {TEMPLATE_DIR}")
else:
    jinja_env = None
    logger.error(f"Jinja2 template directory not found: {TEMPLATE_DIR}. Categorization endpoint may fail.")

# Define contract categories
# TODO: Consider moving this to a config file or database
CONTRACT_CATEGORIES = [
    "Sale and purchase",
    "Service provision",
    "Mandate",
    "Deposit",
    "Contract work",
    "Transport",
    "For use of a tangible good",
    "Money for money: Loan",
    "For use of an intangible good",
    "License agreement",
    "For access",
    "Donation",
    "Commodatum",
    "Association contract",
    "Cooperative contract",
    "Company contract",
    "Distribution/Franchise contract",
    "Guarantee contracts",
    "Gambling contract",
    "Contract in favor of a third party",
    "Contract by person to be named",
    "Contract of assignment of contractual position: Promise to contract",
    "Non-Disclosure Agreement",
    "Intellectual Property Agreement",
]

# Allow CORS for frontend development
origins = [
    "http://localhost",
    "http://localhost:5173",
    "http://127.0.0.1:5173",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- Health check / Hello World Endpoint --- 
@app.get("/api/hello")
async def read_root():
    return {"message": "Hello from FastAPI!"}

# --- New AI Endpoint --- 

class AIPrompt(BaseModel):
    prompt: str
    model: str | None = None # Optional: specify a model like 'gemini-pro'

@app.post("/api/generate")
async def generate_ai_text(request: AIPrompt):
    """Receives a prompt and returns text generated by the AI service."""
    if not request.prompt:
        raise HTTPException(status_code=400, detail="Prompt cannot be empty")
    
    # Use the provided model or the default from ai_service
    model_to_use = request.model if request.model else None 
    
    try:
        if model_to_use:
            generated_text = await generate_text_from_gemini(request.prompt, model_name=model_to_use)
        else:
            generated_text = await generate_text_from_gemini(request.prompt)
        
        if generated_text.startswith("Error:"):
            # Handle errors reported by the service itself
            raise HTTPException(status_code=500, detail=generated_text)
            
        return {"prompt": request.prompt, "response": generated_text}
    except Exception as e:
        # Catch potential unexpected errors during the call
        # Log the error e
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred: {e}")

# --- File Extraction Endpoint --- 

@app.post("/api/extract_text")
async def handle_text_extraction(file: UploadFile = File(...) ):
    """Receives a file (PDF or DOCX), extracts text, and returns it."""
    
    # Basic validation for filename and extension
    filename = file.filename
    if not filename:
        raise HTTPException(status_code=400, detail="No filename provided.")
        
    file_extension = Path(filename).suffix.lower()
    if file_extension not in [".pdf", ".docx"]:
        raise HTTPException(status_code=415, detail=f"Unsupported file type: '{file_extension}'. Please upload a .pdf or .docx file.")

    # Define temporary file path
    temp_file_path = UPLOAD_DIR / filename 
    # Warning: This simple naming can cause conflicts if multiple users upload files
    # with the same name concurrently. A better approach would use unique IDs (e.g., uuid).
    
    logger.info(f"Receiving file: {filename}. Saving temporarily to {temp_file_path}")

    try:
        # Save the uploaded file temporarily
        with temp_file_path.open("wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
            logger.info(f"Successfully saved temporary file: {temp_file_path}")

        # Extract text using the utility function
        extracted_content = extract_text(str(temp_file_path))

        if extracted_content is None:
            # extract_text logs errors, but we should inform the client
            logger.warning(f"Text extraction returned None for file: {filename}")
            # Check if file still exists before raising; maybe it was invalid
            if temp_file_path.exists():
                 raise HTTPException(status_code=500, detail="Failed to extract text from the file. It might be corrupted or empty.")
            else:
                 # This case shouldn't happen if saving succeeded, but good to check
                 raise HTTPException(status_code=500, detail="Internal error during file processing.")

        logger.info(f"Successfully extracted text from {filename}")
        return {"filename": filename, "text": extracted_content}

    except HTTPException as http_exc: 
        # Re-raise HTTPExceptions directly (like the 415 Unsupported Media Type)
        raise http_exc
    except Exception as e:
        logger.error(f"Error processing file {filename}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred while processing the file: {e}")
    finally:
        # Ensure the temporary file is deleted
        if temp_file_path.exists():
            try:
                temp_file_path.unlink()
                logger.info(f"Successfully deleted temporary file: {temp_file_path}")
            except Exception as del_e:
                logger.error(f"Failed to delete temporary file {temp_file_path}: {del_e}")
        # Close the uploaded file handle
        await file.close()

# --- Internal Helper Functions ---

async def _get_contract_category(document_text: str, filename: str) -> str:
    """Internal helper to get contract category using AI."""
    if not jinja_env:
        logger.error(f"[_get_contract_category] Jinja environment not loaded for {filename}")
        raise HTTPException(status_code=500, detail="Internal server error: Template engine not available.")

    # Truncate very long text (reuse existing logic)
    MAX_TEXT_LENGTH = 50000 
    if len(document_text) > MAX_TEXT_LENGTH:
        logger.warning(f"[_get_contract_category] Truncating text for {filename} from {len(document_text)} to {MAX_TEXT_LENGTH} characters.")
        processed_text = document_text[:MAX_TEXT_LENGTH] + "... [TRUNCATED]"
    else:
        processed_text = document_text

    # Prepare the prompt
    try:
        template = jinja_env.get_template("category_prompt.jinja")
        prompt = template.render(document_text=processed_text, categories=CONTRACT_CATEGORIES)
        logger.info(f"[_get_contract_category] Generated category prompt for {filename}")
    except Exception as template_e:
        logger.error(f"[_get_contract_category] Failed to render Jinja template for {filename}: {template_e}", exc_info=True)
        raise HTTPException(status_code=500, detail="Internal server error: Failed to prepare category prompt.")

    # Call the AI service
    logger.info(f"[_get_contract_category] Sending request to AI for {filename}")
    ai_response_raw = await generate_text_from_gemini(prompt)
    
    if ai_response_raw.startswith("Error:"):
        logger.error(f"[_get_contract_category] AI service returned an error for {filename}: {ai_response_raw}")
        # Propagate specific error details if possible
        raise HTTPException(status_code=502, detail=f"AI service failed during categorization: {ai_response_raw}")
    
    # Process AI response
    suggested_category = ai_response_raw.strip()
    logger.info(f"[_get_contract_category] Received category suggestion '{suggested_category}' for {filename}")

    # Validate category
    if suggested_category not in CONTRACT_CATEGORIES:
        logger.warning(f"[_get_contract_category] AI suggested category '{suggested_category}' which is not in the predefined list for {filename}. Using 'Other'.")
        final_category = "Other" # Or potentially raise an error/return None?
    else:
        final_category = suggested_category

    logger.info(f"[_get_contract_category] Determined category for {filename}: {final_category}")
    return final_category

# --- API Endpoints ---

@app.post("/api/analyze/categorize")
async def categorize_contract(file: UploadFile = File(...)):
    """Receives a contract file, extracts text, asks AI to categorize it, and returns the category."""
    # Keep initial file validation and saving logic
    filename = file.filename
    if not filename:
        raise HTTPException(status_code=400, detail="No filename provided.")
    
    file_extension = Path(filename).suffix.lower()
    if file_extension not in [".pdf", ".docx"]:
        raise HTTPException(status_code=415, detail=f"Unsupported file type: '{file_extension}'. Only .pdf and .docx supported for categorization.")

    temp_file_path = UPLOAD_DIR / f"categorize_{filename}" 
    logger.info(f"[Categorize Endpoint] Receiving file: {filename}. Saving temporarily to {temp_file_path}")

    extracted_content = None
    category = None
    try:
        # 1. Save file temporarily
        with temp_file_path.open("wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
            logger.info(f"[Categorize Endpoint] Successfully saved temporary file: {temp_file_path}")

        # 2. Extract text
        extracted_content = extract_text(str(temp_file_path))
        if not extracted_content:
            logger.error(f"[Categorize Endpoint] Text extraction failed or yielded empty content for: {filename}")
            raise HTTPException(status_code=500, detail="Failed to extract text from the file.")
        logger.info(f"[Categorize Endpoint] Successfully extracted text from {filename}. Length: {len(extracted_content)}")
        
        # 3. Call the internal helper function to get the category
        category = await _get_contract_category(extracted_content, filename)
        
        return {"filename": filename, "category": category}

    # Catch potential exceptions from file handling or the helper function
    except HTTPException as http_exc:
        # Re-raise known HTTP exceptions (including those from _get_contract_category)
        raise http_exc
    except Exception as e:
        logger.error(f"[Categorize Endpoint] Error processing file {filename}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred during categorization: {e}")
    finally:
        # 4. Clean up temporary file
        if temp_file_path and temp_file_path.exists():
            try:
                temp_file_path.unlink()
                logger.info(f"[Categorize Endpoint] Successfully deleted temporary file: {temp_file_path}")
            except Exception as del_e:
                logger.error(f"[Categorize Endpoint] Failed to delete temporary file {temp_file_path}: {del_e}")
        # Close the uploaded file handle
        if file:
            await file.close()

# --- New Summary Endpoint --- 

@app.post("/api/analyze/summary")
async def summarize_contract(file: UploadFile = File(...)):
    """Receives a contract file, extracts text, asks AI to summarize it, and returns the summary."""
    
    if not jinja_env:
         raise HTTPException(status_code=500, detail="Template engine not initialized. Check server logs.")

    filename = file.filename
    if not filename:
        raise HTTPException(status_code=400, detail="No filename provided.")
        
    # Check supported file types
    file_extension = Path(filename).suffix.lower()
    if file_extension not in [".pdf", ".docx"]:
        raise HTTPException(status_code=415, detail=f"Unsupported file type: '{file_extension}'. Only .pdf and .docx supported for summarization.")

    temp_file_path = UPLOAD_DIR / f"summary_{filename}" # Use prefix to avoid potential clashes
    logger.info(f"[Summary] Receiving file: {filename}. Saving temporarily to {temp_file_path}")

    extracted_content = None
    try:
        # 1. Save file temporarily
        with temp_file_path.open("wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
            logger.info(f"[Summary] Successfully saved temporary file: {temp_file_path}")

        # 2. Extract text
        extracted_content = extract_text(str(temp_file_path))
        if not extracted_content:
            logger.error(f"[Summary] Text extraction failed or yielded empty content for: {filename}")
            raise HTTPException(status_code=500, detail="Failed to extract text from the file. It might be corrupted, empty, or password-protected.")
        logger.info(f"[Summary] Successfully extracted text from {filename}. Length: {len(extracted_content)}")
        
        # Truncate very long text (consider a larger limit for summaries?)
        MAX_TEXT_LENGTH = 100000 # Example limit, adjust based on model and needs. TODO: evaluate what this should be 
        if len(extracted_content) > MAX_TEXT_LENGTH:
             logger.warning(f"[Summary] Truncating text for {filename} from {len(extracted_content)} to {MAX_TEXT_LENGTH} characters.")
             extracted_content = extracted_content[:MAX_TEXT_LENGTH] + "... [TRUNCATED]"

        # 3. Prepare the prompt using Jinja template
        try:
            template = jinja_env.get_template("summary_prompt.jinja")
            prompt = template.render(document_text=extracted_content)
            logger.info(f"[Summary] Generated prompt for {filename}")
        except Exception as template_e:
            logger.error(f"[Summary] Failed to render Jinja template: {template_e}", exc_info=True)
            raise HTTPException(status_code=500, detail="Internal server error: Failed to prepare analysis prompt.")

        # 4. Call the AI service
        logger.info(f"[Summary] Sending request to AI for {filename}")
        ai_response_raw = await generate_text_from_gemini(prompt) # Consider using a specific model if needed
        
        if ai_response_raw.startswith("Error:"):
            logger.error(f"[Summary] AI service returned an error for {filename}: {ai_response_raw}")
            raise HTTPException(status_code=502, detail=f"AI service failed: {ai_response_raw}")
        
        # 5. Process AI response (basic cleanup)
        summary_text = ai_response_raw.strip()
        logger.info(f"[Summary] Received summary for {filename}. Length: {len(summary_text)}")

        return {"filename": filename, "summary": summary_text}

    except HTTPException as http_exc:
        # Re-raise known HTTP exceptions
        raise http_exc
    except Exception as e:
        logger.error(f"[Summary] Error processing file {filename}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred during summarization: {e}")
    finally:
        # 6. Clean up temporary file
        if temp_file_path and temp_file_path.exists():
            try:
                temp_file_path.unlink()
                logger.info(f"[Summary] Successfully deleted temporary file: {temp_file_path}")
            except Exception as del_e:
                logger.error(f"[Summary] Failed to delete temporary file {temp_file_path}: {del_e}")
        # Close the uploaded file handle
        if file:
            await file.close()

# --- Helper function to load JSON ---
def load_json_file(file_path: Path):
    if not file_path.is_file():
        logger.error(f"JSON file not found: {file_path}")
        return None
    try:
        with file_path.open("r") as f:
            return json.load(f)
    except Exception as e:
        logger.error(f"Error loading JSON file {file_path}: {e}", exc_info=True)
        return None

# --- Load Schemas at Startup ---
REQUIREMENTS_SCHEMA_DATA = load_json_file(PROMPT_DIR / "requirements_schema.json")
REQUIREMENTS_OUTPUT_EXAMPLE_DATA = load_json_file(PROMPT_DIR / "requirements_output_example.json")
CATEGORY_REQUIREMENTS_SCHEMAS = load_json_file(PROMPT_DIR / "category_requirements_schemas.json")

# --- Pydantic Models ---

# General Requirements Models
class RequirementCheckResult(BaseModel):
    met: bool | Literal['maybe']
    explanation: str

class CompletenessCheck(BaseModel):
    date_of_contract_formation: RequirementCheckResult
    parties_involved: RequirementCheckResult
    object_of_contract: RequirementCheckResult
    obligations_of_parties: RequirementCheckResult
    date_of_conclusion: RequirementCheckResult | None = None

class PrecisionCheck(BaseModel):
    terms_clearly_defined: RequirementCheckResult

class FirmnessCheck(BaseModel):
    reciprocal_obligations_established: RequirementCheckResult

class FormalAdequacyCheck(BaseModel):
    formal_requirements_met: RequirementCheckResult

class ContractRequirementsResponse(BaseModel):
    Completeness: CompletenessCheck
    Precision: PrecisionCheck
    Firmness: FirmnessCheck
    FormalAdequacy: FormalAdequacyCheck

# Category-Specific Requirements Models (Moved Here)
class CategoryRequirementsResult(BaseModel):
    met: bool | Literal['maybe']
    explanation: str

class CategoryRequirementsResponse(BaseModel):
    category: str
    analysis: Dict[str, CategoryRequirementsResult] | None = None 
    message: str | None = None 

# --- API Endpoints ---

@app.post("/api/analyze/check-requirements", response_model=ContractRequirementsResponse)
async def check_contract_requirements(file: UploadFile = File(...)):
    """
    Receives a contract file, extracts text, asks AI to check GENERAL requirements 
    based on the predefined schema, and returns the structured result.
    (Overrides Formal Adequacy check).
    """
    if not jinja_env:
         raise HTTPException(status_code=500, detail="Template engine not initialized.")
    if REQUIREMENTS_SCHEMA_DATA is None or REQUIREMENTS_OUTPUT_EXAMPLE_DATA is None:
         raise HTTPException(status_code=500, detail="Failed to load general requirement definition files.")

    filename = file.filename
    if not filename:
        raise HTTPException(status_code=400, detail="No filename provided.")
    
    file_extension = Path(filename).suffix.lower()
    if file_extension not in [".pdf", ".docx"]:
        raise HTTPException(status_code=415, detail=f"Unsupported file type: '{file_extension}'.")

    temp_file_path = UPLOAD_DIR / f"general_req_{filename}" # Use specific prefix
    logger.info(f"[GeneralReq] Receiving file: {filename}. Saving temporarily to {temp_file_path}")

    extracted_content = None
    try:
        # 1. Save & Extract Text (Same as before)
        with temp_file_path.open("wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
        extracted_content = extract_text(str(temp_file_path))
        if not extracted_content:
            raise HTTPException(status_code=500, detail="Failed to extract text.")
        logger.info(f"[GeneralReq] Extracted text from {filename}. Length: {len(extracted_content)}")
        
        # Truncate if needed
        MAX_TEXT_LENGTH = 50000 
        if len(extracted_content) > MAX_TEXT_LENGTH:
             processed_text = extracted_content[:MAX_TEXT_LENGTH] + "... [TRUNCATED]"
        else:
             processed_text = extracted_content

        # 2. Prepare Prompt (Using general template)
        try:
            schema_str = json.dumps(REQUIREMENTS_SCHEMA_DATA, indent=2)
            output_format_str = json.dumps(REQUIREMENTS_OUTPUT_EXAMPLE_DATA, indent=2)
            template = jinja_env.get_template("requirements_prompt.jinja") # General prompt template
            prompt = template.render(
                document_text=processed_text, 
                requirements_schema_str=schema_str,
                output_format_example_str=output_format_str
            )
        except Exception as template_e:
            logger.error(f"[GeneralReq] Failed render template: {template_e}", exc_info=True)
            raise HTTPException(status_code=500, detail="Failed to prepare general analysis prompt.")

        # 3. Call AI
        ai_response_raw = await generate_text_from_gemini(prompt)
        if ai_response_raw.startswith("Error:"):
            raise HTTPException(status_code=502, detail=f"AI service failed (general): {ai_response_raw}")

        # 4. Process and Validate Response (Including 'maybe' fix)
        ai_response_json_str = ai_response_raw.strip()
        if ai_response_json_str.startswith("```json"):
            ai_response_json_str = ai_response_json_str[7:]
        if ai_response_json_str.startswith("```"):
             ai_response_json_str = ai_response_json_str[3:]
        if ai_response_json_str.endswith("```"):
            ai_response_json_str = ai_response_json_str[:-3]
        ai_response_json_str = ai_response_json_str.strip()
        ai_response_json_str = ai_response_json_str.replace(': maybe', ': "maybe"') 

        try:
            ai_response_data = json.loads(ai_response_json_str)
            validated_response = ContractRequirementsResponse(**ai_response_data)
            logger.info(f"[GeneralReq] Parsed/validated general AI response for {filename}")

            # 5. Override Formal Adequacy (Moved back here)
            logger.info(f"[GeneralReq] Overriding FormalAdequacy result for {filename}")
            validated_response.FormalAdequacy.formal_requirements_met.met = "maybe"
            validated_response.FormalAdequacy.formal_requirements_met.explanation = "For formal adequacy, verify the applicable legal requirements in the relevant jurisdiction for the specific type of contract."
            
            return validated_response
        except Exception as e:
            logger.error(f"[GeneralReq] Failed parse/validate general AI response: {e}. Cleaned: {ai_response_json_str}", exc_info=True)
            raise HTTPException(status_code=502, detail=f"General AI response failed validation: {e}")

    except HTTPException as http_exc:
        raise http_exc
    except Exception as e:
        logger.error(f"[GeneralReq] Error processing file {filename}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Unexpected error during general requirements check: {e}")
    finally:
        # Clean up
        if temp_file_path.exists():
            try: temp_file_path.unlink() 
            except Exception as del_e: logger.error(f"Failed delete {temp_file_path}: {del_e}")
        if file: await file.close()

@app.post("/api/analyze/check-category-requirements", response_model=CategoryRequirementsResponse)
async def check_category_requirements(file: UploadFile = File(...)):
    """
    Receives a contract file, determines its category, finds the category-specific 
    schema, asks AI to check requirements against THAT schema, returns structured result.
    """
    if not jinja_env:
        raise HTTPException(status_code=500, detail="Template engine not initialized.")
    if CATEGORY_REQUIREMENTS_SCHEMAS is None:
        raise HTTPException(status_code=500, detail="Failed to load category requirement definition files.")

    filename = file.filename
    if not filename:
        raise HTTPException(status_code=400, detail="No filename provided.")
    
    file_extension = Path(filename).suffix.lower()
    if file_extension not in [".pdf", ".docx"]:
        raise HTTPException(status_code=415, detail=f"Unsupported file type: '{file_extension}'.")

    temp_file_path = UPLOAD_DIR / f"cat_req_{filename}" # Unique prefix
    logger.info(f"[CatReq] Receiving file: {filename}. Saving temporarily to {temp_file_path}")

    extracted_content = None
    category = None
    try:
        # 1. Save & Extract Text 
        with temp_file_path.open("wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
        extracted_content = extract_text(str(temp_file_path))
        if not extracted_content:
            raise HTTPException(status_code=500, detail="Failed to extract text.")
        logger.info(f"[CatReq] Extracted text from {filename}. Length: {len(extracted_content)}")

        # 2. Determine Contract Category (using internal helper)
        category = await _get_contract_category(extracted_content, filename)

        # 3. Find Category-Specific Schema
        category_schema = CATEGORY_REQUIREMENTS_SCHEMAS.get(category)
        if not category_schema or "criteria" not in category_schema or "output_format_example" not in category_schema:
            logger.warning(f"[CatReq] No valid schema found for '{category}' for file {filename}")
            return CategoryRequirementsResponse(category=category, analysis=None, message=f"Specific analysis not available for category: {category}")

        # 4. Prepare the Prompt (using category template)
        # Truncate text if necessary 
        MAX_TEXT_LENGTH = 50000 
        if len(extracted_content) > MAX_TEXT_LENGTH:
             processed_text = extracted_content[:MAX_TEXT_LENGTH] + "... [TRUNCATED]"
        else:
             processed_text = extracted_content
        
        try:
            schema_str = json.dumps(category_schema["criteria"], indent=2)
            output_format_str = json.dumps(category_schema["output_format_example"], indent=2)
            template = jinja_env.get_template("category_requirements_prompt.jinja") # Category prompt
            prompt = template.render(
                document_text=processed_text, 
                contract_category=category,
                requirements_schema_str=schema_str,
                output_format_example_str=output_format_str
            )
        except Exception as template_e:
            logger.error(f"[CatReq] Failed render category template: {template_e}", exc_info=True)
            raise HTTPException(status_code=500, detail="Failed to prepare category analysis prompt.")

        # 5. Call the AI service
        ai_response_raw = await generate_text_from_gemini(prompt)
        if ai_response_raw.startswith("Error:"):
            raise HTTPException(status_code=502, detail=f"AI service failed (category): {ai_response_raw}")

        # 6. Process and validate AI response
        ai_response_json_str = ai_response_raw.strip()
        if ai_response_json_str.startswith("```json"):
            ai_response_json_str = ai_response_json_str[7:]
        if ai_response_json_str.startswith("```"):
            ai_response_json_str = ai_response_json_str[3:]
        if ai_response_json_str.endswith("```"):
            ai_response_json_str = ai_response_json_str[:-3]
        ai_response_json_str = ai_response_json_str.strip()
        ai_response_json_str = ai_response_json_str.replace(': maybe', ': "maybe"') 

        try:
            ai_response_data = json.loads(ai_response_json_str)
            if not isinstance(ai_response_data, dict):
                 raise ValueError("AI response is not a dict.")
            validated_analysis: Dict[str, CategoryRequirementsResult] = {}
            for key, value in ai_response_data.items():
                validated_analysis[key] = CategoryRequirementsResult(**value) 
            logger.info(f"[CatReq] Parsed/validated category AI response for {filename}")
            return CategoryRequirementsResponse(category=category, analysis=validated_analysis)
        except Exception as e:
             logger.error(f"[CatReq] Failed parse/validate category AI response: {e}. Cleaned: {ai_response_json_str}", exc_info=True)
             raise HTTPException(status_code=502, detail=f"Category AI response failed validation: {e}")

    except HTTPException as http_exc:
        raise http_exc
    except Exception as e:
        logger.error(f"[CatReq] Error processing file {filename}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Unexpected error during category requirements check: {e}")
    finally:
        # Clean up
        if temp_file_path.exists():
            try: temp_file_path.unlink() 
            except Exception as del_e: logger.error(f"Failed delete {temp_file_path}: {del_e}")
        if file: await file.close()

# --- Main execution ---
if __name__ == "__main__":
    # Determine host based on environment (e.g., Docker container vs local)
    # Docker typically uses 0.0.0.0 to be accessible outside the container
    host = os.getenv("HOST", "127.0.0.1") 
    port = int(os.getenv("PORT", 8000))
    
    # Log the UPLOAD_DIR and TEMPLATE_DIR at startup
    logger.info(f"FastAPI application starting up...")
    logger.info(f"Upload directory set to: {UPLOAD_DIR.resolve()}")
    if jinja_env:
        logger.info(f"Template directory set to: {TEMPLATE_DIR.resolve()}")
    else:
        logger.warning(f"Template directory not found or not configured.")
        
    uvicorn.run(app, host=host, port=port) # Corrected: pass app object 